<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Algorithms on Class &amp; Objects</title>
    <link>http://classandobjects.com/categories/algorithms/</link>
    <description>Recent content in Algorithms on Class &amp; Objects</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Fri, 27 May 2016 00:36:36 +0530</lastBuildDate>
    <atom:link href="http://classandobjects.com/categories/algorithms/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Can you Boggle Solve?</title>
      <link>http://classandobjects.com/tutorial/python_boggle_solver/</link>
      <pubDate>Fri, 27 May 2016 00:36:36 +0530</pubDate>
      
      <guid>http://classandobjects.com/tutorial/python_boggle_solver/</guid>
      <description>

&lt;p&gt;Boggle is a word game designed by Allan Turoff and originally distributed by Parker Brothers. The game is played using a plastic grid of lettered dice, in which players attempt to find words in sequences of adjacent letters&amp;hellip; &lt;a href=&#34;https://en.wikipedia.org/wiki/Boggle&#34;&gt;Wikipedia&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;problem-statement&#34;&gt;Problem Statement&lt;/h2&gt;

&lt;p&gt;This problem is also &lt;em&gt;said as&lt;/em&gt; &lt;strong&gt;Jigsaw Crossword Puzzle&lt;/strong&gt;. You are given a board containing MxN cells, each letter containing an alphabet of the English language.
The goal of the program is to traverse through different cells to find a given word such that the following conditions are satisfied.&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;The letters of the word must be formed by traveling through a series of adjacent cells. i.e, the next letter in the word can be in any of the eight cells surrounding it.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;If there is a path drawn as the letters of the words are discovered, the path must not cross over itself.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;The word should not use multiple instances of the same cell.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;strong&gt;Result&lt;/strong&gt; should be the number of times the given word occurs!&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://classandobjects.com/images/algorithms/boggle_case.png&#34; alt=&#34;crossover image&#34; title=&#34;Img 1&#34; /&gt;
&lt;img src=&#34;http://classandobjects.com/images/algorithms/boggle_reuse.png&#34; alt=&#34;reuse image&#34; title=&#34;Img 2&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Paths made using &lt;code&gt;pink&lt;/code&gt; are invalid&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;The Input:&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;findme - (the word to be found)
M - (the number of rows)
N - (the number of columns)
a b c d e … (n elements)
.
.
.
.(m rows)
z y s x o …
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;Input Format:&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&#39;word&#39;

5 x 3

r a y x d
w e t r o
o r d o z
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;Output Format:&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;output : 1
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;DIY : It is highly recommended to try solving it without looking ahead!&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;algorithm-pseudo-code&#34;&gt;Algorithm / Pseudo Code&lt;/h2&gt;

&lt;p&gt;This part describes the algorithm or pseudo code for boggle solver.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Step 1:&lt;/strong&gt; Take all required inputs&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Step 2:&lt;/strong&gt; We know that we can move to &lt;strong&gt;8&lt;/strong&gt; adjacent cells. So we will try to &lt;code&gt;generate a tree starting with every letter in the grid&lt;/code&gt; as root&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Step 3:&lt;/strong&gt; Add all adjacent letters as the child. Note that some cases can have less than eight child.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Step 4:&lt;/strong&gt; We should take care of the infinite loop. If we keep adding every element then the tree never terminates. We need a way to reduce our space with every addition. So that in a straight path the &lt;code&gt;character&lt;/code&gt; at same &lt;code&gt;index&lt;/code&gt; is not repeated. In technical term the above process is known as &lt;code&gt;DFS&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Step 5:&lt;/strong&gt; After every addition check if the word is found.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Step 6:&lt;/strong&gt; If the word is found check if that word has crossover(think on it)? If &lt;code&gt;no&lt;/code&gt; then increment the value of your matches.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Step 7:&lt;/strong&gt; After exhausting the search for all the node print out the result!&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
&lt;p&gt;DIY : This should give you some hint! Follow these steps and try building the code you started!&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;code&#34;&gt;Code&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;It is OK to fail. It is not OK to give up!&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;You tried and you found it difficult, it is find. I have also found problems difficult. What I do it try to solve them, if I cannot, I see how others have done it. Then I make sure that next time I can do it for sure!&lt;/p&gt;

&lt;p&gt;I have commented out most of the portions of my code. I have also left it unoptimized for better readability. If you find any line difficult to grasp, feel free to comment below. Here is the code:&lt;/p&gt;

&lt;script src=&#34;//gist.github.com/ankitsinghaniyaz/d3c14f4f586432a26cacab8a7866465a.js&#34;&gt;&lt;/script&gt;
</description>
    </item>
    
  </channel>
</rss>